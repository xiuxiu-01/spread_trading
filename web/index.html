<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Arbitrage Monitor</title>
    <!-- Load Lightweight Charts from local server -->
    <script src="lightweight-charts.js"></script>
    <style>
        :root {
            --bg-color: #0d1117;
            --card-bg: #161b22;
            --text-primary: #c9d1d9;
            --text-secondary: #8b949e;
            --accent: #58a6ff;
            --border: #30363d;
            --green: #238636;
            --red: #da3633;
        }
        
        body {
            background-color: var(--bg-color);
            color: var(--text-primary);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            height: 100vh;
            box-sizing: border-box;
        }

        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--border);
        }

        h1 { margin: 0; font-size: 1.5rem; }

        .status {
            font-size: 0.9rem;
            color: var(--text-secondary);
        }
        .status.connected { color: var(--green); }
        .status.disconnected { color: var(--red); }

        .container {
            display: flex;
            flex: 1;
            gap: 20px;
            overflow: hidden;
        }

        .charts-column {
            flex: 3;
            display: flex;
            flex-direction: column;
            gap: 20px;
            min-width: 0; /* needed for chart resize */
        }

        .chart-container {
            background: var(--card-bg);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 10px;
            flex: 1;
            position: relative;
            min-height: 0;
            display: flex;
            flex-direction: column;
        }
        
        .chart-title {
            margin: 0 0 5px 0;
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        .chart-div {
            flex: 1;
            width: 100%;
        }

        .controls-column {
            flex: 1;
            background: var(--card-bg);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 20px;
            overflow-y: auto;
            max-width: 300px;
        }

        .control-group { margin-bottom: 15px; }
        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.85rem;
            color: var(--text-secondary);
        }
        .control-group input {
            width: 100%;
            background: var(--bg-color);
            border: 1px solid var(--border);
            color: var(--text-primary);
            padding: 5px 10px;
            border-radius: 4px;
            box-sizing: border-box;
        }
        .control-group input:focus {
            outline: none;
            border-color: var(--accent);
        }

        button {
            background-color: #238636;
            color: white;
            border: 1px solid rgba(240,246,252,0.1);
            padding: 5px 16px;
            border-radius: 6px;
            cursor: pointer;
            width: 100%;
            font-weight: 600;
        }
        button:hover { background-color: #2ea043; }
        
        /* Legend for Price Chart */
        .chart-legend {
            position: absolute;
            top: 40px;
            left: 20px;
            z-index: 10;
            font-size: 12px;
            font-family: monospace;
            pointer-events: none;
        }
        .legend-item { margin-bottom: 2px; }
    </style>
</head>
<body>
    <header>
        <h1>Arbitrage Monitor</h1>
        <div id="connectionStatus" class="status disconnected">Disconnected</div>
    </header>

    <div class="header">
        <h1>MT5 <-> OKX Arbitrage Bot</h1>
        <div id="status">Connecting...</div>
    </div>
    
    <div class="panel">
        <h3>Account Info</h3>
        <div style="display: flex; gap: 20px;">
            <div style="flex: 1; padding: 10px; background: #262626; border-radius: 4px;">
                <strong>MT5 (XAU)</strong><br/>
                Equity: <span id="mt5-equity">--</span><br/>
                Positions: <span id="mt5-pos-count">0</span><br/>
                Net Vol: <span id="mt5-net">0.00</span>
            </div>
            <div style="flex: 1; padding: 10px; background: #262626; border-radius: 4px;">
                <strong>OKX (PAXG)</strong><br/>
                USDT Free: <span id="okx-balance">--</span><br/>
                Positions: <span id="okx-pos-count">0</span><br/>
                Net Amt: <span id="okx-net">0.00000000</span>
            </div>
        </div>
    </div>

    <div class="container">
        <div class="charts-column">
            <div class="chart-container" style="flex: 3;">
                <h3 class="chart-title">Price Candles (MT5 vs OKX)</h3>
                <div id="priceChart" class="chart-div"></div>
                <div id="priceLegend" class="chart-legend">
                    <div class="legend-item" style="color: #4caf50">MT5 <span id="mt5Val"></span></div>
                    <div class="legend-item" style="color: #ef5350">OKX <span id="okxVal"></span></div>
                </div>
            </div>
            <div class="chart-container" style="flex: 1;">
                 <h3 class="chart-title">Spread & EMA</h3>
                <div id="spreadChart" class="chart-div"></div>
            </div>
             <div class="chart-container" style="flex: 1;">
                 <h3 class="chart-title">Volume</h3>
                <div id="volumeChart" class="chart-div"></div>
            </div>
        </div>
        
        <div class="controls-column">
            <h3>Parameters</h3>
            <div id="paramsForm">
                <!-- Params generated here -->
                <div class="field-row">
                    <label>Trade Volume (Lot/Oz)</label>
                    <input type="number" step="0.01" id="tradeVol" value="0.01">
                </div>

                <div class="field-row">
                    <label style="display:inline-flex; align-items:center; width:100%; cursor:pointer;">
                        <input type="checkbox" id="chkAutoTrade" style="width: auto; margin-right: 8px;">
                        Enable Auto Trade
                    </label>
                </div>

                <button type="submit" class="primary">Update Params</button>
            </div>
            <button id="updateBtn">Update Params</button>
            <div style="margin-top: 20px; font-size: 0.8rem; color: #8b949e;">
                <p>OKX: <span id="okxSymbol">-</span></p>
                <p>MT5: <span id="mt5Symbol">-</span></p>
            </div>
            <div style="margin-top: 20px; border-top: 1px solid var(--border); padding-top: 20px;">
                <h3>Manual Trading</h3>
                <div class="control-group">
                     <label>Volume (Lots)</label>
                     <input type="number" id="tradeVol" value="0.01" step="0.01">
                </div>
                <div style="display: flex; gap: 10px; margin-bottom: 15px;">
                    <button id="btnLong" style="background-color: var(--green);">Long Spread</button>
                    <button id="btnShort" style="background-color: var(--red);">Short Spread</button>
                </div>
                <div class="control-group">
                    <label for="chkAutoTrade">Enable Auto Trade</label>
                    <input type="checkbox" id="chkAutoTrade">
                </div>
            </div>
            
            <div style="margin-top: 20px; border-top: 1px solid var(--border); padding-top: 20px; max-height: 200px; overflow-y: auto;">
                 <h3>Order History</h3>
                 <div id="orderList" style="font-size: 0.8rem;"></div>
            </div>
            
             <div style="margin-top: 20px; border-top: 1px solid var(--border); padding-top: 20px;">
                 <h3>Backtest</h3>
                 <button id="loadBacktest" style="background-color: var(--accent);">Load 30D Results</button>
                 <div id="backtestStats" style="margin-top: 10px; font-size: 0.8rem;"></div>
             </div>
        </div>
    </div>

    <script>
        function renderAccount(accountState) {
        if (!accountState) return;

        // MT5
        const mt5Bal = accountState.balance.mt5;
        const mt5Pos = accountState.positions.mt5 || [];
        const mt5Net = mt5Pos.reduce((sum, p) => sum + (p.type === 'buy' ? p.volume : -p.volume), 0);
        
        document.getElementById('mt5-equity').textContent = mt5Bal.toFixed(2);
        document.getElementById('mt5-pos-count').textContent = mt5Pos.length;
        document.getElementById('mt5-net').textContent = mt5Net.toFixed(2);
        
        // Color code net exposure
        const elMt5Net = document.getElementById('mt5-net');
        elMt5Net.style.color = mt5Net > 0 ? 'var(--green)' : (mt5Net < 0 ? 'var(--red)' : '#d29922');

        // OKX
        const okxBal = accountState.balance.okx;
        const okxPos = accountState.positions.okx || [];
        let okxNet = 0;
        okxPos.forEach(p => {
            let amt = p.amount;
            if (p.side === 'short') amt = -amt;
            okxNet += amt;
        });
        
        document.getElementById('okx-balance').textContent = okxBal.toFixed(4);
        document.getElementById('okx-pos-count').textContent = okxPos.length;
        document.getElementById('okx-net').textContent = okxNet.toFixed(8);

        const elOkxNet = document.getElementById('okx-net');
        elOkxNet.style.color = okxNet > 0 ? 'var(--green)' : (okxNet < 0 ? 'var(--red)' : '#d29922');
    }

    const { createChart, ColorType, CrosshairMode, LineStyle } = LightweightCharts;

        const chartOptions = {
            layout: {
                textColor: '#c9d1d9',
                background: { type: ColorType.Solid, color: '#161b22' },
            },
           // timezone: 'Asia/Shanghai', // Set chart timezone to China Standard Time
           timezone: 'Etc/UTC', // We are manually shifting data to Beijing Time (UTC+8) before feeding to chart
            grid: {
                vertLines: { color: '#30363d' },
                horzLines: { color: '#30363d' },
            },
            crosshair: {
                mode: CrosshairMode.Normal,
            },
            timeScale: {
                timeVisible: true,
                secondsVisible: false,
                borderColor: '#30363d',
            },
            rightPriceScale: {
                borderColor: '#30363d',
            },
        };

        // 1. Price Chart
        const priceContainer = document.getElementById('priceChart');
        const priceChart = createChart(priceContainer, chartOptions);
        
        // MT5 Candle Series
        const mt5Series = priceChart.addSeries(LightweightCharts.CandlestickSeries, {
            upColor: '#238636', 
            downColor: '#da3633', 
            borderUpColor: '#238636',
            borderDownColor: '#da3633',
            wickUpColor: '#238636',
            wickDownColor: '#da3633',
            title: 'MT5',
        });
        
        // OKX Candle Series
        const okxSeries = priceChart.addSeries(LightweightCharts.CandlestickSeries, {
            upColor: '#4caf50', // Green
            downColor: '#ef5350', // Red
            borderUpColor: '#4caf50',
            borderDownColor: '#ef5350',
            wickUpColor: '#4caf50',
            wickDownColor: '#ef5350',
            title: 'OKX',
        });
        
        // 2. Spread Chart
        const spreadContainer = document.getElementById('spreadChart');
        const spreadChart = createChart(spreadContainer, chartOptions);
        
        const spreadSeries = spreadChart.addSeries(LightweightCharts.LineSeries, {
            color: '#d29922', // Yellow
            lineWidth: 2,
            title: 'Spread',
        });
        const emaSeries = spreadChart.addSeries(LightweightCharts.LineSeries, {
            color: '#ffffff',
            lineWidth: 1,
            lineStyle: LineStyle.Dashed,
            title: 'EMA',
        });
        
        // Bands will be added dynamically. We store references here.
        let bandSeries = [];

        // 3. Volume Chart
        const volContainer = document.getElementById('volumeChart');
        const volChart = createChart(volContainer, {
            ...chartOptions,
            rightPriceScale: {
                 scaleMargins: {
                    top: 0.1,
                    bottom: 0,
                },
            }
        });
        
        const mt5VolSeries = volChart.addSeries(LightweightCharts.HistogramSeries, {
            color: '#26a69a',
            priceFormat: { type: 'volume' },
            title: 'MT5 Vol',
        });
         const okxVolSeries = volChart.addSeries(LightweightCharts.HistogramSeries, {
            color: '#ef5350',
            priceFormat: { type: 'volume' },
             title: 'OKX Vol',
        });

        // Resize observer to handle responsiveness
        new ResizeObserver(entries => {
            if (entries.length === 0 || entries[0].target !== priceContainer) { return; }
            const newRect = entries[0].contentRect;
            priceChart.applyOptions({ width: newRect.width, height: newRect.height });
        }).observe(priceContainer);

        new ResizeObserver(entries => {
            if (entries.length === 0 || entries[0].target !== spreadContainer) { return; }
            const newRect = entries[0].contentRect;
            spreadChart.applyOptions({ width: newRect.width, height: newRect.height });
        }).observe(spreadContainer);
        
        new ResizeObserver(entries => {
            if (entries.length === 0 || entries[0].target !== volContainer) { return; }
            const newRect = entries[0].contentRect;
            volChart.applyOptions({ width: newRect.width, height: newRect.height });
        }).observe(volContainer);
        
        // Sync Reference: https://github.com/tradingview/lightweight-charts/issues/322
        // Simple sync:
        const charts = [priceChart, spreadChart, volChart];
        
        function syncCharts(sourceChart) {
            const range = sourceChart.timeScale().getVisibleLogicalRange();
            if (!range) return;
            charts.forEach(c => {
                if (c !== sourceChart) {
                    c.timeScale().setVisibleLogicalRange(range);
                }
            });
        }
        
        charts.forEach(c => {
            c.timeScale().subscribeVisibleLogicalRangeChange(() => syncCharts(c));
        });

        // WebSocket
        let ws;
        let reconnectTimer;
        const statusEl = document.getElementById('connectionStatus');
        
        function connect() {
            // Allow override via URL query: ?ws=ws://127.0.0.1:8765/ws  or ?wsHost=127.0.0.1:8765
            const qs = new URLSearchParams(window.location.search);
            const wsOverride = qs.get('ws');
            const wsHostOverride = qs.get('wsHost');

            const isFile = window.location.protocol === 'file:';
            const isHttps = window.location.protocol === 'https:';
            const scheme = isHttps ? 'wss' : 'ws';

            const host = wsHostOverride
                ? wsHostOverride
                : (isFile ? 'localhost:8765' : window.location.host);

            const url = wsOverride || `${scheme}://${host}/ws`;
            
            console.log('Connecting to WS:', url);
            statusEl.textContent = 'Connecting...';
            statusEl.className = 'status disconnected';

            try {
                ws = new WebSocket(url);
            } catch (e) {
                console.error('WS Create Error', e);
                scheduleReconnect();
                return;
            }
            
            ws.onopen = () => {
                statusEl.textContent = 'Connected';
                statusEl.className = 'status connected';
                if (reconnectTimer) {
                    clearTimeout(reconnectTimer);
                    reconnectTimer = null;
                }
            };
            
            ws.onclose = () => {
                statusEl.textContent = 'Disconnected (Retrying...)';
                statusEl.className = 'status disconnected';
                scheduleReconnect();
            };

            ws.onerror = (err) => {
                console.error('WS Error', err);
                // Some browsers will also trigger onclose; closing here helps normalize behavior.
                try { ws.close(); } catch (_) {}
            };

            ws.onmessage = (event) => {
                try {
                    const msg = JSON.parse(event.data);
                    handleMessage(msg);
                } catch (e) {
                    console.error('Parse error', e);
                }
            };
        }

        function scheduleReconnect() {
            if (reconnectTimer) return;
            reconnectTimer = setTimeout(() => {
                reconnectTimer = null;
                connect();
            }, 3000);
        }

        const paramsForm = document.getElementById('paramsForm');
        let currentParams = {};
        let backtestMarkers = []; // Store markers from loaded backtest
        
        // Shadow data for live marker calculation
        let globalSpreadData = [];
        let globalEmaData = [];

        function handleMessage(msg) {
            if (msg.type === 'params') {
                updateParamsUI(msg.payload);
            } else if (msg.type === 'account') {
                renderAccount(msg.payload);
            } else if (msg.type === 'bar') {
               updateCharts(msg.payload);
            } else if (msg.type === 'history') {
                loadHistory(msg.payload);
            } else if (msg.type === 'orders') {
                updateOrderList(msg.payload);
            }
        }
        
        // --- Backtest Visualization ---
        document.getElementById('loadBacktest').addEventListener('click', async () => {
             const btn = document.getElementById('loadBacktest');
             btn.disabled = true;
             btn.textContent = 'Loading...';
             
             try {
                const res = await fetch('/backtest_results.json');
                if (!res.ok) throw new Error('Not found');
                const data = await res.json();
                
                // Show stats
                const s = data.summary;
                document.getElementById('backtestStats').innerHTML = 
                    `Trades: ${s.total_trades} | PnL: ${s.total_pnl.toFixed(2)}`;
                
                // Plot entry/exits as markers on the spread chart
                // We need to merge with existing markers
                
                // Reset local store
                backtestMarkers = [];
                 
                 // Process trades
                 data.trades.forEach(t => {
                     // Entry Marker
                     backtestMarkers.push({
                         time: t.entry_ts, // ts is already INT seconds from backtest.py
                         position: 'belowBar',
                         color: '#FF9800',
                         shape: 'arrowUp',
                         text: `Ent L${t.level}`
                     });
                     
                     // Exit Marker
                     backtestMarkers.push({
                         time: t.exit_ts,
                         position: 'aboveBar',
                         color: '#9C27B0',
                         shape: 'arrowDown',
                         text: `Ex ${t.pnl.toFixed(1)}`
                     });
                 });
                 
                 // Trigger update to merge
                 // We need spreadData/emaData to re-run updateMarkers...
                 // But we don't have them easily accessible here without querying the series or storing them.
                 // Easier approach: Just set them now, and let next 'updateCharts' merge them?
                 // No, 'updateCharts' is called inside 'loadHistory' (historical).
                 // Live updates call 'updateCharts' -> 'updateMarkers'? 
                 // Wait, 'updateCharts' receives a single BAR. It doesn't call 'updateMarkers' (which loops over history).
                 
                 // Let's check updateCharts.
                 
                 markers.sort((a,b) => a.time - b.time);
                 spreadSeries.setMarkers(markers);
                 
             } catch (e) {
                 alert('Failed to load backtest results: ' + e);
             } finally {
                 btn.disabled = false;
                 btn.textContent = 'Load 30D Results';
             }
        });
        
        // --- Order Handling ---
        
        document.getElementById('btnLong').addEventListener('click', () => {
             const vol = document.getElementById('tradeVol').value;
             // Send parameters update first to set volume preferrence on backend? 
             // Ideally we send volume in the command. But for now based on backend logic:
             // Backend reads tradeVolume from params. Let's update params or assume default
             // A better way is to send 'make_long' with arguments.
             
             // Updating params first to ensure volume is correct
             ws.send(JSON.stringify({
                 type: 'params',
                 payload: { tradeVolume: parseFloat(vol) }
             }));
             
             setTimeout(() => {
                 ws.send(JSON.stringify({ type: 'make_long' }));
             }, 100);
        });
        
        document.getElementById('btnShort').addEventListener('click', () => {
             const vol = document.getElementById('tradeVol').value;
             ws.send(JSON.stringify({
                 type: 'params',
                 payload: { tradeVolume: parseFloat(vol) }
             }));
             setTimeout(() => {
                 ws.send(JSON.stringify({ type: 'make_short' }));
             }, 100);
        });

        // Auto Trade Checkbox Handler
        const autoTradeCheckbox = document.getElementById('chkAutoTrade');
        if (autoTradeCheckbox) {
            autoTradeCheckbox.addEventListener('change', (e) => {
                const auto = e.target.checked;
                ws.send(JSON.stringify({
                    type: 'params',
                    payload: { autoTrade: auto }
                }));
            });
        }
        
        // Add Close All Button Handler
        const closeAllBtn = document.createElement('button');
        closeAllBtn.innerText = 'CLOSE ALL POSITIONS';
        closeAllBtn.style.backgroundColor = '#da3633'; // Red
        closeAllBtn.style.marginTop = '10px';
        closeAllBtn.onclick = () => {
             if(confirm("Are you sure you want to CLOSE ALL positions on MT5 and OKX?")) {
                 ws.send(JSON.stringify({ type: 'close_all' }));
             }
        };
        // Append to control panel
        document.querySelector('.controls-column').appendChild(closeAllBtn);

        function updateOrderList(orders) {
            const list = document.getElementById('orderList');
            list.innerHTML = '';
            
            // Show latest first
            const sorted = [...orders].sort((a,b) => b.id - a.id);
            
            sorted.forEach(o => {
                const item = document.createElement('div');
                item.style.borderBottom = '1px solid #30363d';
                item.style.padding = '5px 0';
                
                const timeStr = new Date(o.ts).toLocaleTimeString();
                
                const color = o.direction === 'long' ? 'var(--green)' : 'var(--red)';

                let statusColor = '#8b949e';
                if (o.status === 'filled') statusColor = 'var(--green)';
                if (o.status === 'failed') statusColor = 'var(--red)';

                item.innerHTML = `
                    <div style="display: flex; justify-content: space-between;">
                        <span style="font-weight: bold; color: ${color}">${o.direction.toUpperCase()}</span>
                        <span style="color: #8b949e">${timeStr}</span>
                    </div>
                    <div>Vol: ${o.vol} | Status: <span style="color: ${statusColor}">${o.status}</span></div>
                    ${o.error ? `<div style="color: var(--red); font-size: 0.7em;">${o.error}</div>` : ''}
                `;
                list.appendChild(item);
            });
        }

        // Format of history payload: { ts: [time1, time2...], mt5: [candle1...], okx: [candle2...] }
        // Each candle: { time, open, high, low, close, vol }
        function loadHistory(history) {
            console.log('Received history:', history);
            
            // User request: Add 8 hours to historical time for correct display
            const OFFSET_SECONDS = 8 * 3600;

            const mt5Data = history.mt5.map(c => ({
                time: c.time + OFFSET_SECONDS,
                open: c.open,
                high: c.high,
                low: c.low,
                close: c.close
            }));
            
            const okxData = history.okx.map(c => ({
                time: c.time + OFFSET_SECONDS,
                open: c.open,
                high: c.high,
                low: c.low,
                close: c.close
            }));

            // sort by time just in case
            mt5Data.sort((a,b) => a.time - b.time);
            okxData.sort((a,b) => a.time - b.time);

            mt5Series.setData(mt5Data);
            okxSeries.setData(okxData);
            
            const mt5VolData = history.mt5.map(c => ({
                 time: c.time + OFFSET_SECONDS,
                 value: c.volume,
                 color: (c.close >= c.open) ? '#26a69a' : '#ef5350'
            }));
             const okxVolData = history.okx.map(c => ({
                 time: c.time + OFFSET_SECONDS,
                 value: c.volume,
                 color: (c.close >= c.open) ? '#4caf50' : '#ef5350'
            }));
            
            mt5VolSeries.setData(mt5VolData);
            okxVolSeries.setData(okxVolData);
            
            // Reconstruct spread and EMA history roughly
            // We need joined data for this.
            // Create a map of time -> okx candle
            const okxMap = new Map();
            okxData.forEach(c => okxMap.set(c.time, c));

            const spreadData = [];
            
            // Iterate MT5 and find matching OKX
            mt5Data.forEach(m => {
                // Since we already shifted both, we can keys match directly
                const o = okxMap.get(m.time);
                if (o) {
                    spreadData.push({
                        time: m.time,
                        value: m.close - o.close
                    });
                }
            });
            
            if (spreadData.length > 0) {
                spreadSeries.setData(spreadData);
                
                // Calculate simplistic EMA locally for display
                // Backend sends parameters, we can use the default or current one
                const period = currentParams.emaPeriod || 60; 
                const emaData = calculateEMA(spreadData, period);
                emaSeries.setData(emaData);

                // Add markers logic here based on spread/EMA crossing or external signals
                updateMarkers(spreadData, emaData); 
            }
            
            // Adjust scale to fit
            priceChart.timeScale().fitContent();
        }

        function updateMarkers(spreadData, emaData) {
            // Visualize simplistic strategy signals on the chart
            // For now, let's just mark where Spread crosses EMA
            // Real application would receive explicit signals from backend
            
            let markers = [...backtestMarkers]; // Start with backtest markers
            
            // Basic simplistic crossover
            for(let i=1; i<spreadData.length; i++) {
                const prevS = spreadData[i-1].value;
                const currS = spreadData[i].value;
                const prevE = emaData[i-1].value;
                const currE = emaData[i].value;
                
                // Bullish Cross (Spread goes above EMA)
                if (prevS <= prevE && currS > currE) {
                     markers.push({
                        time: spreadData[i].time,
                        position: 'belowBar',
                        color: '#2196F3',
                        shape: 'arrowUp',
                        text: 'CrossUp'
                    });
                }
                // Bearish Cross (Spread goes below EMA)
                else if (prevS >= prevE && currS < currE) {
                    markers.push({
                        time: spreadData[i].time,
                        position: 'aboveBar',
                        color: '#E91E63',
                        shape: 'arrowDown',
                        text: 'CrossDown'
                    });
                }
            }
            // Sort by time
            markers.sort((a,b) => a.time - b.time);
            spreadSeries.setMarkers(markers);
        }

        function calculateEMA(data, period) {
             const k = 2 / (period + 1);
             let ema = data[0].value;
             return data.map(d => {
                 ema = d.value * k + ema * (1 - k);
                 return { time: d.time, value: ema };
             });
        }

        function updateParamsUI(params) {
            currentParams = { ...currentParams, ...params };
            document.getElementById('mt5Symbol').textContent = params.MT5_SYMBOL || '-';
            document.getElementById('okxSymbol').textContent = params.OKX_SYMBOL || '-';

            const editableKeys = ['emaPeriod', 'firstSpread', 'nextSpread', 'takeProfit', 'maxPos'];
            paramsForm.innerHTML = '';
            
            editableKeys.forEach(key => {
                if (params[key] !== undefined) {
                    const div = document.createElement('div');
                    div.className = 'control-group';
                    const label = document.createElement('label');
                    label.textContent = key;
                    const input = document.createElement('input');
                    input.type = 'number';
                    input.value = params[key];
                    input.dataset.key = key;
                    input.step = key.includes('Spread') || key.includes('Profit') ? '0.1' : '1';
                    div.appendChild(label);
                    div.appendChild(input);
                    paramsForm.appendChild(div);
                }
            });

            document.getElementById('pTakeProfit').value = params.takeProfit || 6.0;
            document.getElementById('pMaxPos').value = params.maxPos || 3;
            document.getElementById('tradeVol').value = params.tradeVolume || 0.01;
            
            const chkAuto = document.getElementById('chkAutoTrade');
            if (chkAuto && params.autoTrade !== undefined) {
                chkAuto.checked = params.autoTrade;
            }

            currentParams = params;
        }

        document.getElementById('updateBtn').addEventListener('click', () => {
            const inputs = paramsForm.querySelectorAll('input');
            const payload = {};
            inputs.forEach(input => {
                payload[input.dataset.key] = parseFloat(input.value);
            });
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ type: 'params', payload }));
            }
        });

        // Helper to convert ISO string to timestamp for chart
        // Lightweight charts expects seconds (UNIX) or 'yyyy-mm-dd' string. 
        // For intraday, we need UNIX timestamp (seconds).
        function toTime(isoStr) {
             // The backend sends ISO string in UTC or with offset.
             // Lightweight charts with "timezone: 'Asia/Shanghai'" expects a UTC timestamp (seconds),
             // and IT will apply the shift (UTC+8) when rendering the label.
             // However, if we feed it a timestamp that is ALREADY shifted, and tell it to shift again, it might be double shifting or confusing.
             
             // NEW REQUIREMENT: User says "Historical time should add 8 hours to display correctly".
             // This likely means the historical data is coming as UTC timestamp, and the chart is NOT adding 8 hours automatically,
             // OR the chart IS adding 8 hours but the source data was somehow treated as local.
             
             // Let's standardise:
             // 1. We receive UTC timestamp (seconds) or ISO string (UTC).
             // 2. We want to DISPLAY Beijing Time.
             
             // If chart option timezone: 'Asia/Shanghai' is set, it takes a UTC timestamp and displays it as UTC+8.
             // If the user says it's still missing 8 hours, it implies we might need to manually shift it if the library isn't doing what we expect for history.
             
             // BUT, modifying 'toTime' affects live updates too. Let's look at loadHistory.
             
             return Math.floor(new Date(isoStr).getTime() / 1000); 
        }

        function updateCharts(bar) {
            // Apply +8h offset to live data too, to match history
            const OFFSET_SECONDS = 8 * 3600;
            const time = toTime(bar.ts) + OFFSET_SECONDS;
            
            // 1. Price
            // MT5
            if (bar.mt5.close > 0) {
                 mt5Series.update({
                    time: time,
                    open: bar.mt5.open,
                    high: bar.mt5.high,
                    low: bar.mt5.low,
                    close: bar.mt5.close
                });
            }
            // OKX
            if (bar.okx.close > 0) {
                okxSeries.update({
                    time: time,
                    open: bar.okx.open,
                    high: bar.okx.high,
                    low: bar.okx.low,
                    close: bar.okx.close
                });
            }
            
            // Legend Update
            if (bar.mt5.close > 0) document.getElementById('mt5Val').textContent = bar.mt5.close.toFixed(2);
            if (bar.okx.close > 0) document.getElementById('okxVal').textContent = bar.okx.close.toFixed(2);

            // 2. Spread
            spreadSeries.update({ time: time, value: bar.spread });
            emaSeries.update({ time: time, value: bar.ema });
            
            // Update shadow data for markers
            // We append new bar to global data
            // To prevent duplicates, check last time
            if (globalSpreadData.length === 0 || globalSpreadData[globalSpreadData.length-1].time !== time) {
                globalSpreadData.push({ time: time, value: bar.spread });
                globalEmaData.push({ time: time, value: bar.ema });
                
                // Keep buffer size reasonable
                if (globalSpreadData.length > 5000) {
                    globalSpreadData = globalSpreadData.slice(-5000);
                    globalEmaData = globalEmaData.slice(-5000);
                }
                
                // Re-calculate markers periodically or on new bar?
                // For simplicity, re-run updateMarkers with the latest window
                // But updateMarkers processes the WHOLE array. 
                // Optimization: Just check the last few points?
                // 'updateMarkers' sorts and replaces ALL markers. 
                // So calling it here is fine but overhead.
                updateMarkers(globalSpreadData, globalEmaData);
            }
            
            // Bands
            // Ensure band series exist
            if (bandSeries.length < bar.bands.length * 2) {
                 const currentPairs = bandSeries.length / 2;
                 for (let i = currentPairs; i < bar.bands.length; i++) {
                     const lvl = i + 1;
                     const u = spreadChart.addSeries(LightweightCharts.LineSeries, {
                         color: 'rgba(57, 211, 83, 0.4)',
                         lineWidth: 1,
                         title: `Upper L${lvl}`
                     });
                     const l = spreadChart.addSeries(LightweightCharts.LineSeries, {
                         color: 'rgba(57, 211, 83, 0.4)',
                         lineWidth: 1,
                         title: `Lower L${lvl}`
                     });
                     bandSeries.push(u);
                     bandSeries.push(l);
                 }
            }
            
            // Update bands
            bar.bands.forEach((b, i) => {
                const uSeries = bandSeries[i * 2];
                const lSeries = bandSeries[i * 2 + 1];
                if (uSeries) uSeries.update({ time: time, value: b.upper });
                if (lSeries) lSeries.update({ time: time, value: b.lower });
            });

            // 3. Volume
            mt5VolSeries.update({ time: time, value: bar.mt5.vol });
            okxVolSeries.update({ time: time, value: bar.okx.vol });
        }

        connect();
    </script>
</body>
</html>
